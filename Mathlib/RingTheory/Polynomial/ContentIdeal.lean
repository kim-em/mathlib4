/-
Copyright (c) 2025 Fabrizio Barroero. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Fabrizio Barroero
-/

import Mathlib.Order.CompletePartialOrder
import Mathlib.RingTheory.Ideal.BigOperators
import Mathlib.RingTheory.Polynomial.Content

/-!
# The content ideal of a polynomial

## Main Definitions
Let `p : R[X]`.
- `p.contentIdeal` is the `Ideal R` generated by the coefficients of `p`.
-

## Main Results
-
-

-/

namespace Polynomial

open Ideal

variable {R : Type*} [Semiring R] (p : R[X])

/-- The content ideal of a polynomial `p` is the ideal generated by its coefficients. -/
def contentIdeal := span (p.coeffs.toSet)

theorem contentIdeal_def : p.contentIdeal = span (p.coeffs.toSet) := rfl

@[simp]
theorem contenIdeal_zero : (0 : R[X]).contentIdeal = ⊥ := by
  simp [contentIdeal_def]

@[simp]
theorem contentIdeal_eq_bot_iff : p.contentIdeal = ⊥ ↔ p = 0 := by
  simp only [contentIdeal_def, span_eq_bot, Finset.mem_coe]
  refine ⟨?_, fun h ↦ by simp [h]⟩
  contrapose!
  exact fun h ↦ ⟨p.leadingCoeff, coeff_mem_coeffs p p.natDegree (leadingCoeff_ne_zero.mpr h),
    leadingCoeff_ne_zero.mpr h⟩

theorem coeff_mem_contentIdeal (n : ℕ) : p.coeff n ∈ p.contentIdeal := by
  by_cases h : p.coeff n = 0
  · simp [h]
  · apply subset_span
    simpa using coeff_mem_coeffs p n h

@[simp]
theorem contentIdeal_monomial (n : ℕ) (r : R) : (monomial n r).contentIdeal = Ideal.span {r} := by
  by_cases h : r = 0
  · simp [h, Set.singleton_zero]
  · rw [contentIdeal_def, coeffs_monomial _ h, Finset.coe_singleton]

@[simp]
theorem contentIdeal_C (r : R) : (C r).contentIdeal = Ideal.span {r} := by
  rw [← monomial_zero_left]
  exact contentIdeal_monomial 0 r

section CommSemiring

variable {R : Type*} [CommSemiring R] --(p : R[X])

theorem contentIdeal_le_contentIdeal_of_dvd {p q : R[X]} (hpq : p ∣ q) :
    q.contentIdeal ≤ p.contentIdeal := by
  rw [contentIdeal_def, span_le]
  intro _ h1
  rw [Finset.mem_coe, mem_coeffs_iff] at h1
  obtain ⟨_, _, h2⟩ := h1
  obtain ⟨_, h3⟩ := hpq
  rw [h3, coeff_mul] at h2
  rw [h2]
  exact Ideal.sum_mem _ <| fun _ _ ↦ mul_mem_right _ _ <| coeff_mem_contentIdeal p _
/-
theorem mem_contentIdeal_of_dvd {p : R[X]} {r : R} (h : C r ∣ p) :
    r ∈ p.contentIdeal := by
  rw [contentIdeal_def, mem_span]
  intro I hI
  rw [C_dvd_iff_dvd_coeff] at h


  sorry -/

theorem _root_.Submodule.IsPrincipal.contentIdeal_generator_dvd {p : R[X]}
    (h_prin : Submodule.IsPrincipal p.contentIdeal) :
    C (h_prin.generator) ∣ p := by
  rw [C_dvd_iff_dvd_coeff]
  intro n
  have := p.coeff_mem_contentIdeal n
  rw [Submodule.IsPrincipal.mem_iff_eq_smul_generator] at this
  obtain ⟨_, ha⟩ := this
  simp [ha]

theorem _root_.Submodule.IsPrincipal.contentIdeal_le_span_iff_dvd {p : R[X]}
    (h_prin : Submodule.IsPrincipal p.contentIdeal) (r : R) :
     p.contentIdeal ≤ span {r} ↔ C r ∣ p := by
  let s := h_prin.generator
  constructor
  · rw [← span_singleton_generator p.contentIdeal]
    intro h
    calc
    C r ∣ C s := by
      apply RingHom.map_dvd C
      rw [← span_singleton_le_span_singleton]
      exact h
     _   ∣ p := h_prin.contentIdeal_generator_dvd
  · rw [← contentIdeal_C r]
    exact fun h ↦ contentIdeal_le_contentIdeal_of_dvd h

/-- If the coefficients of `p` geneate the whole ring, then `p` is primitive. -/
theorem isPrimitive_of_contentIdeal_eq_top {p : R[X]} (h : p.contentIdeal = ⊤) :
    IsPrimitive p := by
  have h_prin : Submodule.IsPrincipal p.contentIdeal := by
    rw [h]
    exact top_isPrincipal
  intro r
  simp [← h_prin.contentIdeal_le_span_iff_dvd r, h]
  /- by_contra h
  simp only [IsPrimitive, not_forall, Classical.not_imp] at h
  obtain ⟨r, hr, _⟩ := h
  apply contentIdeal_le_contentIdeal_of_dvd at hr
  simp_all -/

theorem _root_.Submodule.IsPrincipal.isPrimitive_iff_contentIdeal_eq_top {p : R[X]}
    (h_prin : Submodule.IsPrincipal p.contentIdeal)  : IsPrimitive p ↔ p.contentIdeal = ⊤ := by
  refine ⟨?_, fun a ↦ isPrimitive_of_contentIdeal_eq_top a⟩
  contrapose!
  simp only [IsPrimitive, not_forall]
  intro _
  use Submodule.IsPrincipal.generator p.contentIdeal, h_prin.contentIdeal_generator_dvd
  simp_all [← Ideal.span_singleton_eq_top]

end CommSemiring

section IsBezout

variable {R : Type*} [CommSemiring R] [IsBezout R] (p : R[X])

/-- The polynomial `p` is primitive if and only if the coefficients of `p` geneate the whole ring.
-/
theorem isPrimitive_iff_contentIdeal_eq_top : IsPrimitive p ↔ p.contentIdeal = ⊤ :=
  Submodule.IsPrincipal.isPrimitive_iff_contentIdeal_eq_top <|
  IsBezout.isPrincipal_of_FG _ ⟨p.coeffs, rfl⟩

end IsBezout

end Polynomial
