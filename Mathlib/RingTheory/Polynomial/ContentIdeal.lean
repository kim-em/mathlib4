/-
Copyright (c) 2025 Fabrizio Barroero. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Fabrizio Barroero
-/

import Mathlib.Order.CompletePartialOrder
import Mathlib.RingTheory.Ideal.BigOperators
import Mathlib.RingTheory.Polynomial.Content

/-!
# The content ideal of a polynomial

## Main Definitions
Let `p : R[X]`.
- `p.contentIdeal` is the `Ideal R` generated by the coefficients of `p`.
-

## Main Results
-
-

-/

namespace Polynomial

open Ideal

variable {R : Type*} [Semiring R] (p : R[X])

/-- The content ideal of a polynomial `p` is the ideal generated by its coefficients. -/
def contentIdeal := span (p.coeffs.toSet)

theorem contentIdeal_def : p.contentIdeal = span (p.coeffs.toSet) := rfl

@[simp]
theorem contenIdeal_zero : (0 : R[X]).contentIdeal = ⊥ := by
  simp [contentIdeal_def]

@[simp]
theorem contentIdeal_bot_iff : p.contentIdeal = ⊥ ↔ p = 0 := by
  simp only [contentIdeal_def, span_eq_bot, Finset.mem_coe]
  refine ⟨?_, fun h ↦ by simp [h]⟩
  contrapose!
  exact fun h ↦ ⟨p.leadingCoeff, coeff_mem_coeffs p p.natDegree (leadingCoeff_ne_zero.mpr h),
    leadingCoeff_ne_zero.mpr h⟩

theorem coeff_mem_contentIdeal (n : ℕ) : p.coeff n ∈ p.contentIdeal := by
  by_cases h : p.coeff n = 0
  · simp [h]
  · rw [contentIdeal_def, mem_span]
    exact fun _ hJ ↦ Set.mem_of_subset_of_mem hJ <| Finset.mem_coe.mpr <| coeff_mem_coeffs p n h

@[simp]
theorem contentIdeal_monomial (n : ℕ) (r : R) : (monomial n r).contentIdeal = Ideal.span {r} := by
  by_cases h : r = 0
  · simp [h, Set.singleton_zero]
  · rw [contentIdeal_def, coeffs_monomial _ h, Finset.coe_singleton]

@[simp]
theorem contentIdeal_C (r : R) : (C r).contentIdeal = Ideal.span {r} := by
  rw [← monomial_zero_left]
  exact contentIdeal_monomial 0 r

section CommSemiring

variable {R : Type*} [CommSemiring R] --(p : R[X])

theorem contentIdeal_le_contentIdeal_of_dvd {p q : R[X]} (hpq : p ∣ q) :
    q.contentIdeal ≤ p.contentIdeal := by
  rw [contentIdeal_def, span_le]
  intro _ h1
  rw [Finset.mem_coe, mem_coeffs_iff] at h1
  obtain ⟨_, _, h2⟩ := h1
  obtain ⟨_, h3⟩ := hpq
  rw [h3, coeff_mul] at h2
  rw [h2]
  exact Ideal.sum_mem _ <| fun _ _ ↦ mul_mem_right _ _ <| coeff_mem_contentIdeal p _

theorem dvd_of_mem_of_isPrincipal_contentIdeal {p : R[X]}
    (h_princ : Submodule.IsPrincipal p.contentIdeal) :
    C (h_princ.generator) ∣ p := by
  rw [C_dvd_iff_dvd_coeff]
  intro n
  have := p.coeff_mem_contentIdeal n
  rw [Submodule.IsPrincipal.mem_iff_eq_smul_generator] at this
  obtain ⟨_, ha⟩ := this
  simp [ha]

/-- If the coefficients of `p` geneate the whole ring, then `p` is primitive. -/
theorem isPrimitive_of_contentIdeal_eq_top {p : R[X]} (h : p.contentIdeal = ⊤) :
    IsPrimitive p := by
  by_contra h
  simp only [IsPrimitive, not_forall, Classical.not_imp] at h
  obtain ⟨r, hr, _⟩ := h
  apply contentIdeal_le_contentIdeal_of_dvd at hr
  simp_all

end CommSemiring

section IsBezout

variable {R : Type*} [CommSemiring R] [IsBezout R] (p : R[X])

/-- The polynomial `p` is primitive if and only if the coefficients of `p` geneate the whole ring.
-/
theorem isPrimitive_iff_contentIdeal_eq_top :
    IsPrimitive p ↔ p.contentIdeal = ⊤ := by
  refine ⟨?_, fun a ↦ isPrimitive_of_contentIdeal_eq_top a⟩
  contrapose!
  simp only [IsPrimitive, not_forall]
  intro h
  have : Submodule.IsPrincipal p.contentIdeal := IsBezout.isPrincipal_of_FG _ ⟨p.coeffs, rfl⟩
  use Submodule.IsPrincipal.generator p.contentIdeal, dvd_of_mem_of_isPrincipal_contentIdeal this
  simp_all [← Ideal.span_singleton_eq_top]

end IsBezout

end Polynomial
